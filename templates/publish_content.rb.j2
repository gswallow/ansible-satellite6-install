#!/usr/bin/ruby

require 'time'
require 'rest-client'
require 'json'

ME = '{{ satellite_deployment_hostname_full }}'
URL = "https://#{ME}"
ORG_NAME = '{{ satellite_deployment_organization }}'
CV_NAME = 'default'
FOREMAN_URL = "#{URL}/api/v2"
TASKS_URL = "#{URL}/foreman_tasks/api"
KATELLO_URL = "#{URL}/katello/api/v2"
PER_PAGE=100

$username = 'admin'
$password = File.read('/root/.satellite_password').chomp

# Performs a GET using the passed URL location
def get_json(location, page = 1)
  location = "#{location}?page=#{page}&per_page=#{PER_PAGE}"
  response = RestClient::Request.new(
    :method => :get,
    :url => location,
    :user => $username,
    :password => $password,
    :headers => { :accept => :json, :content_type => :json }
  ).execute
  JSON.parse(response.to_str)
end

# Performs a POST using the passed URL location
def post_json(location, json_data = {})
  location = "#{location}"
  response = RestClient::Request.new(
    :method => :post,
    :url => location,
    :user => $username,
    :password => $password,
    :headers => { :accept => :json, :content_type => :json },
    :payload => JSON.generate(json_data)
  ).execute
  JSON.parse(response.to_str)
end

# Performs a POST using the passed URL location
def delete_json(location, json_data = {})
  location = "#{location}"
  response = RestClient::Request.new(
    :method => :delete,
    :url => location,
    :user => $username,
    :password => $password,
    :headers => { :accept => :json, :content_type => :json },
    :payload => JSON.generate(json_data)
  ).execute
  JSON.parse(response.to_str)
end

def poll_task(id)
  poll_result = get_json("#{TASKS_URL}/tasks/#{id}")
  while poll_result['state'] != "stopped" do
    sleep 5
    poll_result = get_json("#{TASKS_URL}/tasks/#{id}")
  end
  poll_result['result']
end

def run_task(path, params = {})
  res = poll_task post_json(path, params)['id']
  sleep 30
  res
end

def delete_task(path, params = {})
  res = poll_task delete_json(path, params)['id']
  sleep 30
  res
end

def order_of(lifecycle_envs = [])
  order = Array.new
  lifecycle_envs.each do |e|
    if e['prior'].nil?
      order.unshift({'name' => e['name'], 'id' => e['id']})
    elsif order.include?(e['prior']['name'])
      order.insert(order.index(e['prior']['name']) + 1, {'name' => e['name'], 'id' => e['id']})
    else
      order.push({'name' => e['name'], 'id' => e['id']})
    end
  end
  order.reject! { |e| e['name'] == 'Library' }
end

def organizations
  get_json("#{FOREMAN_URL}/organizations")['results']
end

def my_org_id
  organizations.map { |o| o['id'] if o['name'] == ORG_NAME }.first
end

def content_views
  get_json("#{KATELLO_URL}/content_views")['results'] 
end

def my_content_view_id
  content_views.map { |v| v if v['name'] == CV_NAME }.first['id']
end

def content_view_versions
  versions = get_json("#{KATELLO_URL}/content_views/#{my_content_view_id}/")['versions']
  versions.sort { |v1, v2| v1['version'] <=> v2['version'] }
end

def latest_version_id
  content_view_versions.last['id']
end

def paths
  get_json("#{KATELLO_URL}/organizations/#{my_org_id}/environments/paths")['results'].first
end

def lifecycle_environments
  paths['environments']
end
  
# ----------v do the things v-------- # 

# Publish a new version of the content view
print "Publishing new version of the #{CV_NAME} content view..."
puts run_task("#{KATELLO_URL}/content_views/#{my_content_view_id}/publish")

# Publish the new version of the content view to each lifecycle environment, in order, except to Library
if res == "success"
  order_of(lifecycle_envs).each do |e|
    print "Promoting version #{latest_version_id} of #{CV_NAME} to #{e['name']}..."
    puts run_task("#{KATELLO_URL}/content_view_versions/#{latest_version_id}/promote", {'environment_id' => e['id']})
  end
end

# Cleanup everything except for the last three versions
content_view_versions[0..-3].each do |v|
  print "Deleting version #{v['version']}..."
  puts delete_task("#{KATELLO_URL}/content_view_versions/#{v['id']}")
end
